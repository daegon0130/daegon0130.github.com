---
layout: post
title: 운영체제(OS) (1)
subtitle: 프로세스와 스레드
categories: CS지식
tags: [운영체제, OS, 기술면접]
---
## 프로세스와 스레드
---
### 프로그램
- 파일 시스템에 존재하는 실행 파일

### 프로세스
- 메모리에 적재되어서 실행되고 있는 프로그램.  
  실행되고 있는 프로그램의 인스턴스. (운영체제가 관리하는 작업의 단위.)
- 운영체제로부터 시스템 자원을 할당받는다.  
    → Cpu 시간, 운용되기 위한 필요한 주소 공간, Code, Data, Stack, Heap의 구조로 되어있는 독립된 메모리 영역.
- **프로세스 간에는 메모리 등의 자원을 공유하지 않는다(쓰레드와 가장 큰 차이점)**  
    한 프로세스는 다른 프로세스의 메모리 공간(변수나 자료구조)에 접근할 수 없으며, 접근을 위해선 IPC통신이 필요하다. ex) 파이프, 파일, 공유메모리, 소켓 등을 이용한 통신방법
- IPC (Inter Process communication) : 독립된 프로세스끼리 통신을 하기 위한 방법
    - PIPE: 익명의 PIPE를 통해 동일한 PPID를 가진 프로세스들 간의 단방향 통신을 지원. FIFO 구조. 부모 자식 프로세스 간 통신할 때 사용. 쌍방 통신을 위해서는 Write용 PIPE하나 Read PIPE하나 씩 만들어야 한다.
    - named pipe(FIFO): 이름을 가진 PIPE를 통해 프로세스들 간의 단방향 통신을 지원. 서로 다른 프로세스들이 PIPE의 이름을 알면 통신이 가능. FIFO 구조. 쌍방 통신을 위해서는 Write용 PIPE하나 Read PIPE하나 씩 만들어야 한다.
    - Message Queue: 메모리를 사용한 PIPE. 구조체를 기반으로 통신. FIFO구조. 프로세스간 다양한 통신을 할때 사용할 수 있다.
    - Shared Memory: 시스템 상의 공유메모리를 통해 통신.
    - Socket: 네트워크 소켓 통신을 사용한 데이터 공유.
    - [https://doitnow-man.tistory.com/110](https://doitnow-man.tistory.com/110)
- 운영체제는 프로세스의 상태를 실행, 준비, 블록 상태 등 으로 분류하여 관리하며, 프로세스 스케줄링을 통해 CPU 코어에서 실행될 프로세스를 선택한다.

### 스레드
- 프로세스 안에서 실행되는 하나의 실행 흐름을 말한다.
- 프로세스 내의 주소 공간이나 자원을 공유.
- 프로세스 내의 Code, Data, Heap 영역은 다른 스레드와 공유하고 Stack 영역은 따로 할당을 받는다. (Code: 실행 코드를 가지고 있음. 힙: 사용자가 동적 할당하는 메모리 영역, 데이터: 전역 변수, static 변수 등, stack: 함수 매개변수, 지역 변수)
- **별도의 레지스터와 스택을 가지고 있으며, 이외에 다른 영역을 공유한다.** 한 스레드가 프로세스의 자원을 변경하면, 다른 스레드도 그 변경결과를 즉시 확인할 수 있다.

### 프로세스의 메모리 구조
- **Code 영역**  
    실행 코드를 가지고 있다. 프로그램을 실행시키는 실행 파일 내의 명령어들이 올라간다.
- **Data 영역**  
    전역변수, static변수가 할당됨
- **Stack 영역**  
    함수의 매개변수, 함수 내 지역변수
- **Heap 영역**  
    사용자가 동적 할당하는 메모리 영역

### 프로세스 제어 블록 (PCB, Process Control Block)
- 특정 프로세스에 대한 정보를 저장하고 있는 커널 내의 자료구조.
- OS는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다.
- PCB에 저장되는 정보
    - 프로세스 식별자(PID) : 프로세스 식별 번호
    - 프로세스 상태: new, ready, running, waiting, terminated 등의 상태를 저장
    - 프로그램 카운터(PC): 프로세스가 다음에 실행할 명령어의 주소를 가리킴.
    - CPU 레지스터
    - CPU 스케줄링 정보
    - 메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보
    - 입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록
    - 어카운팅 정보: 사용된 CPU 시간. 시간 제한. 계정 번호 등


### 멀티프로세싱

프로세서는 원래 한번에 하나의 프로세스만 실행시킬 수 있다.  
멀티 프로세싱은 프로세서 하나가 프로세스 여러 개를 돌아가며 정해진 시간동안 수행하는 방식이다.

이렇게 진행중인 작업을 바꾸는걸 **'Context Switching'**

이라고 부르는데 이 과정이 매우 빠른 속도로 돌아가게 되면서 사람들에게는 이 프로세스들이 동시에 진행되는 것 처럼 보인다.  


### Context Switching
- CPU(프로세서)는 한번의 하나의 프로세스만 처리 가능.
- 여러 프로세스를 처리하는 과정에서 현재 진행 중인 Task(프로세스, 스레드)의 상태를 PCB에 저장하고 다음에 진행할 Task의 상태값을 읽어 적용하는 과정을 말한다.
- 멀티 프로세스에서 프로세스를 실행하고 있는 상태에서 다른 프로세스를 실행해야 할때, 기존 프로세스의 상태 및 레지스터의 값을 저장하고, 다음 프로세스 실행을 위해 상태 정보 및 레지스터의 값을 교체하는 작업. 이 정보들은 PCB에 저장된다.
- 다른 프로세스에게 CPU를 할당해 작업을 수행하는 과정을 말한다.
- 과정
    - Task의 대부분의 정보는 Resister에 저장되고 PCB로 관리된다.
    - 현재 실행하고 있는 Task의 PCB정보를 저장한다.
    - 다음 실행할 Task의 PCB정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.
- Context Switching은 많은 비용이 소모된다.
- Context Switching의 비용은 프로세스가 스레드보다 더 많이 든다.
- 이유: 스레드는 stack영역을 제외한 모든 메모리를 공유하기 때문에 Context Switching 발생시 Stack영역 만 변경을 진행하면 되기 때문이다.
- Context Switching이 발생할 때:  I/O 작업, CPU사용 시간 만료, 자식 프로세스 생성, 인터럽트


### 멀티 스레드 vs 멀티 프로세스

**장점**

- 생성 오버헤드가 적다
- 스레드 간 context switching이 가볍다.
    
    프로세스 스위치를 하면 실행되는 프로세스가 다른 프로세스를 실행하니 전에 프로세스가 사용하는 것은 완전히 다른 메모리이다. 이럴 경우 캐시 미스(Cache Miss)가 난다. 여태까지 사용한 데이터는 날아가고 새로 해서 캐시 미스가 계속 난다. 그런데 멀티스레드를 하면 캐시 미스가 덜 일어난다. 그래서 스위치 오버헤드가 적다.
    
- 스레드간 통신이 간단하다

**단점**

- 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료됨.
- 동기화 문제
    
    서로 다른 스레드가 프로세스 내 메모리를 공유한다. 자원 공유의 문제.
    
- 디버깅이 어렵다.
    
    프로그램은 하나인데 이 안에서 프로그램 안에 여러 군데가 동시에 실행되고 있기 때문에, 명령어가 어떤 순서로 일어나는지 알 수 없다.
    

멀티 프로세싱 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다.

### 싱글 스레드 vs 멀티 스레드

- 싱글 스레드 장점
    - 동기화 문제를 신경쓰지 않아도 된다.
        
        멀티 스레드의 경우 자원을 공유하기 때문에 동기화 이슈를 항상 신경써야 함. 
        
    - Context Switching을 하지 않음.
        
        문맥교환(Context Switching)으로 인해 발생되는 시간지연이 없다.
        
- 싱글 스레드 단점
    - CPU 코어를 모두 활용하지 못함
- 멀티 스레드 장점
    - 여러 코어를 활용하여 작업을 병렬적으로 처리..
- 멀티 스레드 단점
    - 동기화 문제, Context Switching으로 인한 시간 지연.


### 싱글스레드 프로그램 멀티코어
- 싱글 스레드가 동시에 여러개의 코어에서 동작하는 경우는 없다.


### 멀티코어

CPU = 프로세서

코어는 각종 연산을 하는 CPU의 핵심 요소. CPU 안에서 일하는 부품.

멀티 코어 시스템: 이것은 코어라고 불리는 두 개 이상의 독립된 처리장치를 가진 단일 컴퓨팅 컴포넌트입니다. 이러한 코어는, 프로그램 명령을 개별적으로 읽어, 실행할 수 있습니다. 즉, 시스템에는 복수의 코어를 탑재한 1개의 CPU가 탑재되어 있습니다.

cf) 하이퍼쓰레딩

하나의 코어에서 둘 이상의 스레드를 실행할 수 있는 것. 스레드가 많을수록 더 많은 작업을 병렬로 수행할 수 있음. 명령어 단위의 병렬성을 쓰레드단위의 병렬성을 이용하여 극대화 하자는게 HT목적입니다. 현실적으로는 명령어가 겹치는게 많아서 HT가 효과를 보는 경우는 거의 없습니다.


### 유저 모드와 커널 모드

커널에서 중요한 자원을 관리하기 때문에, 사용자가 그 중요한 자원에 접근하지 못하도록 모드를 2가지로 나눈 것.

- 유저 모드
    - 유저(사용자)가 접근할 수 있는 영역을 제한적으로 둠으로서 프로그램의 자원에 함부로 침범하지 못하는 모드
    - 우리는 여기서 코드를 작성하고, 프로세스를 실행하는 등의 행동을 함
- 커널 모드
    - 모든 자원(드라이버, 메모리, CPU등)에 접근, 명령을 할 수 있다.

프로세스가 실행되는 동안, 프로세스는 수없이 유저 모드와 커널 모드를 왔다갔다 하면서 실행이 됨.

- 유저모드 → 커널 모드 요청
    
    프로세스가 유저모드에서 실행되다가 특별한 요청이 필요할 때, system call(시스템 콜)을 이용해서 커널에 요청을 함
    
- 커널모드 → 유저모드로 반환
    
    system call의 요청을 받은 커널이  그 요청에 대한 일을 하고 결과값을 system call의 리턴 값으로 전해 줌. 시스템콜(프로세스 제어, 파일 조작(파일 생성, 삭제 등), 장치관리, 통신(메세지 송신, 수신 등)
   
    
### 동기화 문제

한정적인 시스템 자원에 여러 스레드가 동시에 접근해서 사용하면 문제가 발생할 수 있다. 이 문제를 방지하기 위한 기법

- 스레드 동기화
    - 실행 순서의 동기화
        
        스레드의 실행 순서를 정의하고, 이 순서를 반드시 따르도록 하는 것.
        
    - 메모리 접근에 대한 동기화
        
        메모리 접근에 있어서 동시 접근을 막는 것
        
- 동기화 기법
    - 유저 모드의 동기화
        - 커널의 힘을 빌리지 않는 동기화 기법. 커널의 코드가 실행되지 않음
        - 성능상 이점이 있으나 기능상의 제한점이 존재. 상당히 빠름.
        - 임계 구역(critical section) 기반의 동기화, 인터락 함수 기반의 동기화
            - critical section 기반의 동기화 (critical section은 동기화 문제의 일으키는 코드블록)
                - 한번의 하나의 스레드만이 접근 가능. 열쇠를 얻은 프로세스만이 critical section으로 들어갈 수 있다.
                - critical section 진입을 위해 critical section object를 얻음.
            - 인터락 함수 기반의 동기화
                - 함수 내부적으로 한 순간에 하나의 스레드에 의해서만 실행되도록 동기화된다.
                - 임계 구역 기반의 동기화도 내부적으로 인터락 함수를 기반으로 구현.
    - 커널 모드의 동기화
        - 커널에서 제공하는 동기화 기능을 이용하는 방법.
        - 커널 모드로의 변경이 필요하고 이는 성능 저하로 일어난다. 그러나 다양한 기능을 활용할 수 있다.
        - 세마포어, 뮤텍스, 모니터 등등
            - 세마포어
                
                현재 공유자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법
                
            - 뮤텍스
                
                한 스레드, 프로세스에 의해 소유될 수 있는 key를 기반으로 한 상호배제 기법.
                
            - 세마포어와 뮤텍스의 목적
                
                상호 배제를 달성하는 것. 특정 동기화 대상이 이미 특정 스레드에 의해 사용 중일 경우, 다른 스레드가 해당 동기화 대상에 접근하는 것을 제한하는 것.
                
            - 세마포어와 뮤텍스의 차이
                
                관리하는 동기화 대상이 몇개인가에 따라
                
            - 뮤텍스, 모니터, 세마포어의 차이
                
                뮤텍스, 모니터는 상호 배제를 함으로써 임계구역(공유 자원에 접근하는 프로세스 내부의 코드 영역)에 하나의 스레드만 들어갈 수 있음. 세마포어는 여러개의 스레드가 들어갈 수 있다.
                
            - 뮤텍스와 모니터의 차이
                
                뮤텍스는 다른 프로세스 간에 동기화할 때 사용할 수 있음. 모니터는 하나의 프로세스 내에에 다른 스레드 간의 동기화할 때 사용. 
                보통 뮤텍스는 운영체제 커널에 의해 제공. 
                모니터는 프레임워크나 라이브러리 그 자체에서 제공. 
                따라서 뮤텍스는 무겁고 느리며, 모니터는 가볍고 빠르다.
                
            - 모니터와 세마포어 차이
                
                관리하는 동기화 대상의 몇개인지(모니터는 이진 세마포어만 가능, 세머포어는 binary 세머포어가 아니라 counting 세마포어를 제공)
                세마포어에 비해 모니터쪽이 접근할 수 있는 락의 획득과 해제가 간단하다. 세마포어는 직접 키해제와 공유자원 접근 처리를 해주어야 한다. 자바는 모니터 방식.

### 교착 상태
    
한정된 자원을 여러 프로세스가 사용하려 할 때 발생하는 문제.  
다중 프로세싱 환경에서 두 개 이상의 프로세스가 특정 자원할당을 무한정 대기하는 상태. 
    
- 발생조건
    - 상호배제(Mutual Exclusion)

        자원은 한 번에 한 프로세스 만이 사용 가능
        
    - 점유 대기(Hold and Wait)
        
        최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
        
    - 비선점(No Preemption)
        
        다른 프로세스에 할당된 자원은 사용이 끝나서 반납할 때까지 강제로 빼앗을 수 없다.
        
    - 순환 대기(Circular Wait)
        
        프로세스의 집합 {P0, P1, ..., Pn}에서 0은 1이 점유한 자원을 대기하고 1은 2가 점유한 자원을 대기하고 Pn은 P0이 점유한 자원을 요구해야 한다.
        
        이처럼 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.
        
- 해결방안
    
    4가지: 교착상태 예방, 회피, 탐지, 복구
    
- 교착 상태 예방
    
    교착 상태 발생 조건 중 하나를 제거함으로써 해결
    
    1. 상호 배제 부정  
    여러 프로세스가 공유 자원을 사용하도록 한다.
    2. 점유 대기 부정  
    프로세스가 실행되기 전 필요한 모든 자원을 할당.
    3. 비선점 부정  
    점유중인 프로세스가 다른 자원을 요구할 때, 점유 중인 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.
    4. 순환 대기 부정  
    자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.
    
- 교착 상태 회피 기법 - > 자원을 할당해도 안정 상태인지 사전에 검사 /은행원 알고리즘
    - 은행원 알고리즘에서 운영체제는 안정상태를 유지할 수 잇는 요구만을 수락하고 불안정 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절합니다. (최소 고객 한명에게 대출해줄 금액은 항상 은행이 보유하고 있어야 한다'는 개념에서 나옴.
    - 안정상태(safe state)
        
        시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태로 안전순서열이 존재하는 상태를 말합니다.
        
    - 불안정상태(Unsafe state)
        
        안전순서열이 존재하지 않는 상태를 말합니다. 
        
        불안정상태는 교착상태이기 위한 필요조건. 
        
        교착상태는 불안정상태에서만 발생. Unsafe state라고 해서 무조건 교착 상태가 발생하는 것은 아님. 
        
    - 프로세스가 가지고 있어야 할 자원의 최대 개수를 미리 알아야 하기 때문에 오버헤드가 크다 → 현재 채택하고 있는 방식x

- 교착 상태 탐지
    
    자원 할당 그래프를 통해 교착 상태를 탐지
    
- 교착 상태 회복 (복구)
    
    교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 해제함으로써 회복하는 것을 의미
    
    1. 프로세스를 종료
    2. 자원을 선점

## 질문
---
<details>
<summary>스택을 스레드마다 독립적으로 할당하는 이유</summary>

    스택은 함수 호출 시 전달되는 인자, 복귀 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간.  
    스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능함을 의미하고 이는 독립적인 실행 흐름이 추가된다는 것이다.  
    따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.
    
</details>
    
<details>
<summary>PC 레지스터를 스레드마다 독립적으로 할당하는 이유</summary>
    
    PC 값은 스레드가 명령어의 어디까지 수행했는지를 나타내게 된다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.  
</details>
    
<details>
<summary>멀티 프로세스 대신 멀티 스레드를 사용하는 이유는?</summary>
    
    - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다. → 시스템 자원 소모가 줄어든다.
    - 스레드는 프로세서 내의 메모리를 공유하기 때문에 데이터 전달이 간단하므로 IPC에 비해 비용이 적고 더 빠르다. → 스레드는 프로세스의 Stack 영역을 제외한 모든 메모리를 공유하기 때문이다.
    - Context Switching시, 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠르다. → 스레드는 Stack영역만 초기화하면 되기 때문이다.
</details>  

<br/>

### 참고자료
https://github.com/JaeYeopHan/Interview_Question_for_Beginner  
https://github.com/WooVictory/Ready-For-Tech-Interview  
https://about-myeong.tistory.com/34  
[https://velog.io/@goblin820/TIL-4-쓰레드Thread-싱글과-멀티-쓰레드](https://velog.io/@goblin820/TIL-4-%EC%93%B0%EB%A0%88%EB%93%9CThread-%EC%8B%B1%EA%B8%80%EA%B3%BC-%EB%A9%80%ED%8B%B0-%EC%93%B0%EB%A0%88%EB%93%9C)