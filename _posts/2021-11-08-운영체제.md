---
layout: post
title: 운영체제(OS) (3)
subtitle: 메모리 관리
categories: CS지식
tags: [운영체제, OS, 기술면접]
---
### 가상 메모리
    
사용자들에게 매우 큰 (주) 메모리로 보이게 만드는 것을 말한다.  
각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식이다.


가상적으로 주어진 주소를 가상 주소(virtual address) 또는 논리 주소(logical address) 라고 하며, 실제 메모리 상에서 유효한 주소를 물리 주소(physical address) 또는 실주소(real address)라고 한다. 가상 주소의 범위를 가상 주소 공간, 물리 주소의 범위를 물리 주소 공간이라고 한다.   


가상 주소 공간은 메모리 관리 장치(MMU)에 의해서 물리 주소로 변환된다. 이 덕분에 프로그래머는 가상 주소 공간상에서 프로그램을 짜게 되어 프로그램이나 데이터가 주메모리상에 어떻게 존재하는지를 의식할 필요가 없어진다. 대부분의 현대적 아키텍처와 운영 체제는 가상 메모리 기능을 제공한다.


프로세스의 필요한 부분을 메모리에 적재하는 것 -> valid bit 메모리에 있으면 1 없으면 0
만약 valid bit가 0일 때 인터럽트를 통해 디스크에 접근하여 해당 부분을 찾아서 메모리에 올린다.

### 페이징 & 세그멘테이션
    
가상 메모리를 관리하는 기법.

가상 메모리는 실행 중인 프로세스가 가상의 공간을 참조하여 마치 커다란 물리 메모리를 갖고 있는 것처럼 사용할 수 있도록 하는 것. 

- 페이징
    - 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재하는 방식
    - 페이지와 동일한 크기로 메모리를 자른 것을 프레임이라고 한다.
    - CPU는 논리주소를 통해 프로세스를 찾는다. 이 논리주소를 실제 페이지가 저장된 물리주소로 변환하여 메모리에서 찾게 되는데 이때 **페이지 테이블**을 이용한다.
    - (예를 들어 50번지라는 논리 주소를 물리 주소로 바꾸고 싶다고 한다고 가정해보자. 이때 페이지의 크기는 16바이트이다. 50번지를 2진수로 바꾸게 되면 110010이 된다. 이때 페이지의 크기가 16바이트이므로 하위 4비트는 n비트가 되고 앞의 두 비트가 페이지 번호를 나타내는 인덱스 값이 된다. 그러면 페이지 테이블에서 11에 해당하는 3의 값을 가진 페이지 번호로 가게 되어 페이지 테이블 값을 읽는다. 만약 이 때의 페이지 테이블 값이 8이라고 하면 8과 n비트를 합쳐서 물리 주소를 가지게 된다. 그 값은 10000010 이라는 메모리 공간의 주소로 가게 되는 것이다. 10진수로 바꾸게 되면 130번지가 된다. 다시 해석하게 되면 테이블 값의 8은 128번지를 의미하게 되고 여기서 하위 n비트의 변위 값에 의해 130번지에서 이 프로세스의 페이지가 동작하게 되는 것이다.)
    TLB(Translation Look-aside Buffer)는 참조했던 페이지를 담아주는 캐시 역할을 한다. TLB는 key-value pair로 데이터를 관리하는 acssociative memory이며, CPU는 page table보다 TLB을 우선적으로 참조
    - 외부 단편화 문제 해소. 내부 단편화 문제 일어남. 프로세스의 크기가 페이지 크기의 배수가 아니라면 마지막 프로세스의 페이지는 한 프레임을 다 채울 수 없기 때문
- 세그멘테이션
    - 프로세스를 물리적인 단위인 페이지 말고 논리적 내용 단위인 세그먼트로 자름.
    - 주소 변환 페이징과 같음.
    - 세그먼트 테이블은 세그먼트 번호와 시작 주소, 세그먼트 크기를 엔트리로 갖는다.
    - 보호와 공유의 기능을 수행
    - 보호- r, w, x 비트를 만들어 해당 세그먼트에 대한 접근 제어를 가능하게 해주는데 세그먼테이션은 논리적으로 나누기 때문에 해당 비트를 설정하기 매우 간단하고 안전하다.  
    공유- 같은 프로그램을 사용하는 여러 프로세스가 있다면 메모리에 하나만 적재하여 프로세서의 세그먼트 테이블 코드 영역을 공유한다. 페이징에서는 code 영역을 나눈다해도 다른 영역이 포함될 확률이 매우 높다. 세그멘테이션이 더 효율적
    - 외부단편화 문제 발생. 세그먼트의 크기가 각각 다르기 때문에
- 두 방식의 장점을 취하기 위해 세그먼트를 페이징하는 기법을 사용.  
    보호와 공유에서 효율적이고, 외부 단편화 문제를 해결
    세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두번해야 한다. 즉, CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야 한다. 속도 측면에서 불리해짐.

### 페이지 교체 알고리즘
- LRU(Least Recently Used) - 가장 오랜 기간 사용되지 않은 페이지를 교체,  
- FIFO 알고리즘,  
- LFU(Least Frequently Used) - 알고리즘의 운영에 오버헤드가 발생, 
- 클럭 알고리즘(NRU : Not Recently Used, NUR : Not Used Recently)- LRU의 개선 기법으로, 참조 비트와 변형 비트를 두어 최근에 사용하지 않은 페이지를 교체,  
- OPT(최적 알고리즘)- 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법

가상 메모리는 요구 페이징 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둔다.


## 요구 페이징(demand paging)
![요구페이징](https://1.bp.blogspot.com/-o8AqdgzCqUs/WRxgx5xWNGI/AAAAAAAABSs/p30dpHJHwtcKS671feGtSuWcbzMrDJdXgCLcB/s1600/DemandPaging2.jpg)
- 페이지 테이블을 검사하여 필요로 하는 페이지의 메모리 참조가 유효(valid)한지, 유효하지 않은지(invalid)
판단한다.  
-  유효하지 않은(invalid) 상태라면 운영체제에게 트랩(trap)을 건다. 운영체제는 invalid 한 경우가 메모리
경계를 넘는 것이라면 프로그램을 종료시키고, 페이지 폴트(page fault)라면 free frame 을 찾는다.
-  디스크에서 해당 페이지를 로딩하라고 I/O 요청을 하며, 프로세스를 waiting 상태로 바꾼다.
-  페이지가 free frame 에 로딩이 완료되었다는 인터럽트가 오면 페이지 테이블에 접근해서 상태를 invalid 에서
valid 로 변경한 후, 프로세스를 waiting 에서 ready 로 변경한다.
-  페이지 폴트(page fault)를 야기했던 인스트럭션부터 다시 수행한다.


### 스레싱 
**메모리 영역에 접근하게 될 때, 메모리에 페이지 부재(=페이지 폴트(Page fault)율이 높은 것**을 의미하며, 심각한 성능 저하를 초래


### 캐싱
    
캐시의 지역성:

- 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성.
- 공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

캐시 구조  
- Fully Associative  
호출되는 블록이 캐쉬 내 어느곳에나 위치할 수 있는 방식이다. 즉, 블록을 찾기위해서는 모든 캐쉬내 블록을 찾아야한다.
- set associative 캐시  
여러개의 set에 각 set 마다 정해진 block이 들어가는 것이다. 따라서, Direct Mapped에서 나머지 연산(Modulo Arithmetic)을 수행할때, 캐쉬내 블록의 개수로(사실은 Direct Mapped에서는 블록이 하나의 set이다.) Mod를 수행하던것에 반해, Set Associative는 블록의 인덱스를 찾기위해서 Set의 개수로 Mod를 수행한다.한 블록이 들어갈 수 있는 자리의 개수가 고정되어 있다.(정해진 수만큼) 이때 자리의 개수를 n개라고 하면, n-way Set Associative cache라고 부른다.Set가 너무 커져 캐쉬 전체가 하나의 set인 것이 Fully Associative이다
- Direct-Mapped  
캐시에 들어갈 위치가 Data주소에 따라 하나로 고정되어 있음

<br/>

### 참고자료
<https://github.com/JaeYeopHan/Interview_Question_for_Beginner>  
<https://github.com/WooVictory/Ready-For-Tech-Interview>  
<https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC>  
[https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jkssleeky&logNo=220478400046](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jkssleeky&logNo=220478400046)
<https://copycode.tistory.com/98>